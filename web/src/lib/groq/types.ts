/**
 * Ghost Note - Groq API Types
 *
 * Type definitions for the Groq API client. These types mirror the Groq
 * OpenAI-compatible API structure.
 *
 * @module lib/groq/types
 */

// =============================================================================
// Chat Message Types
// =============================================================================

/**
 * Role of a message in a chat conversation
 */
export type ChatRole = 'system' | 'user' | 'assistant';

/**
 * A single message in a chat conversation
 */
export interface ChatMessage {
  /** The role of the message sender */
  role: ChatRole;
  /** The content of the message */
  content: string;
}

// =============================================================================
// Request Types
// =============================================================================

/**
 * Parameters for a chat completion request
 */
export interface ChatCompletionRequest {
  /** Array of messages in the conversation */
  messages: ChatMessage[];
  /** Model to use for completion (default: llama-3.3-70b-versatile) */
  model?: string;
  /** Sampling temperature (0-2, default: 0.7) */
  temperature?: number;
  /** Maximum tokens to generate (default: 4096) */
  max_tokens?: number;
  /** Nucleus sampling parameter (0-1) */
  top_p?: number;
}

/**
 * Configuration options for the Groq client
 */
export interface GroqClientConfig {
  /** Base URL for the Supabase Edge Function */
  supabaseUrl: string;
  /** Optional request timeout in milliseconds (default: 60000) */
  timeout?: number;
  /** Optional default model override */
  defaultModel?: string;
  /** Optional default temperature */
  defaultTemperature?: number;
  /** Optional default max tokens */
  defaultMaxTokens?: number;
}

// =============================================================================
// Response Types
// =============================================================================

/**
 * A choice in a chat completion response
 */
export interface ChatCompletionChoice {
  /** Index of the choice */
  index: number;
  /** The generated message */
  message: ChatMessage;
  /** Reason why the model stopped generating */
  finish_reason: 'stop' | 'length' | 'content_filter' | null;
}

/**
 * Token usage statistics from a completion
 */
export interface ChatCompletionUsage {
  /** Tokens in the prompt */
  prompt_tokens: number;
  /** Tokens generated by the model */
  completion_tokens: number;
  /** Total tokens used */
  total_tokens: number;
}

/**
 * Successful chat completion response
 */
export interface ChatCompletionResponse {
  /** Unique identifier for the completion */
  id: string;
  /** Object type (always 'chat.completion') */
  object: 'chat.completion';
  /** Unix timestamp when completion was created */
  created: number;
  /** Model used for the completion */
  model: string;
  /** Array of generated choices */
  choices: ChatCompletionChoice[];
  /** Token usage statistics */
  usage: ChatCompletionUsage;
}

// =============================================================================
// Error Types
// =============================================================================

/**
 * Error types from the Groq API
 */
export type GroqErrorType =
  | 'invalid_request'
  | 'authentication_error'
  | 'rate_limit_error'
  | 'api_error'
  | 'network_error'
  | 'server_error';

/**
 * Error response structure from the API
 */
export interface GroqErrorResponse {
  error: {
    /** Human-readable error message */
    message: string;
    /** Error type category */
    type: GroqErrorType;
    /** Optional error code for specific errors */
    code?: string;
  };
}

/**
 * Custom error class for Groq API errors
 */
export class GroqError extends Error {
  /** Error type category */
  readonly type: GroqErrorType;
  /** Optional error code */
  readonly code?: string;
  /** HTTP status code */
  readonly status: number;

  constructor(
    message: string,
    type: GroqErrorType,
    status: number,
    code?: string
  ) {
    super(message);
    this.name = 'GroqError';
    this.type = type;
    this.status = status;
    this.code = code;
  }

  /**
   * Whether this error is retryable
   */
  get isRetryable(): boolean {
    return (
      this.type === 'rate_limit_error' ||
      this.type === 'network_error' ||
      (this.type === 'api_error' && this.status >= 500)
    );
  }

  /**
   * Whether this is a rate limit error
   */
  get isRateLimited(): boolean {
    return this.type === 'rate_limit_error';
  }

  /**
   * Create a GroqError from a JSON error response
   */
  static fromResponse(json: GroqErrorResponse, status: number): GroqError {
    return new GroqError(
      json.error.message,
      json.error.type,
      status,
      json.error.code
    );
  }
}

// =============================================================================
// Type Guards
// =============================================================================

/**
 * Type guard to check if a value is a valid ChatMessage
 */
export function isChatMessage(value: unknown): value is ChatMessage {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  const msg = value as Record<string, unknown>;
  return (
    (msg.role === 'system' || msg.role === 'user' || msg.role === 'assistant') &&
    typeof msg.content === 'string'
  );
}

/**
 * Type guard to check if a value is a valid ChatCompletionResponse
 */
export function isChatCompletionResponse(value: unknown): value is ChatCompletionResponse {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  const resp = value as Record<string, unknown>;
  return (
    typeof resp.id === 'string' &&
    resp.object === 'chat.completion' &&
    typeof resp.created === 'number' &&
    typeof resp.model === 'string' &&
    Array.isArray(resp.choices) &&
    typeof resp.usage === 'object'
  );
}

/**
 * Type guard to check if a value is a GroqErrorResponse
 */
export function isGroqErrorResponse(value: unknown): value is GroqErrorResponse {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  const resp = value as Record<string, unknown>;
  if (typeof resp.error !== 'object' || resp.error === null) {
    return false;
  }
  const error = resp.error as Record<string, unknown>;
  return typeof error.message === 'string' && typeof error.type === 'string';
}

// =============================================================================
// Helper Types
// =============================================================================

/**
 * Result type for async operations that can fail
 */
export type GroqResult<T> =
  | { success: true; data: T }
  | { success: false; error: GroqError };

/**
 * Create a successful result
 */
export function success<T>(data: T): GroqResult<T> {
  return { success: true, data };
}

/**
 * Create a failed result
 */
export function failure<T>(error: GroqError): GroqResult<T> {
  return { success: false, error };
}
