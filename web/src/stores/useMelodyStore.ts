/**
 * Ghost Note - Melody Store
 *
 * Manages melody generation, ABC notation, and playback state.
 *
 * @module stores/useMelodyStore
 */

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import type { MelodyStore, MelodyState } from './types';
import type { PoemAnalysis } from '../types';
import type { Melody } from '../lib/melody/types';

// =============================================================================
// Initial State
// =============================================================================

const initialState: MelodyState = {
  melody: null,
  abcNotation: null,
  playbackState: 'stopped',
  currentTime: 0,
  duration: 0,
  tempo: 100,
  volume: 0.8,
  loop: false,
  key: 'C',
  timeSignature: '4/4',
  isGenerating: false,
  error: null,
};

// =============================================================================
// Store Implementation
// =============================================================================

export const useMelodyStore = create<MelodyStore>()(
  devtools(
    persist(
      (set, get) => ({
        // State
        ...initialState,

        // Actions
        generateMelody: async (lyrics: string, analysis: PoemAnalysis) => {
          if (!lyrics.trim()) {
            console.warn('[MelodyStore] Cannot generate melody for empty lyrics');
            get().setError('Cannot generate melody for empty lyrics');
            return;
          }

          console.log('[MelodyStore] Starting melody generation');

          set(
            {
              isGenerating: true,
              error: null,
            },
            false,
            'generateMelody/start'
          );

          try {
            // Get suggested parameters from analysis
            const suggestions = analysis.melodySuggestions;
            const state = get();

            // Use current settings or suggestions
            const key = state.key;
            const timeSignature = suggestions.timeSignature || state.timeSignature;
            const tempo = suggestions.tempo || state.tempo;

            // Simulate melody generation
            // In production, this would call the actual melody generator
            await new Promise((resolve) => setTimeout(resolve, 500));

            // Create placeholder melody
            const melody: Melody = {
              params: {
                title: analysis.meta.title || 'Untitled',
                timeSignature,
                defaultNoteLength: '1/8',
                tempo,
                key,
              },
              measures: [],
              lyrics: [],
            };

            // Generate simple ABC notation header
            const abc = `X:1
T:${melody.params.title}
M:${timeSignature}
L:1/8
Q:1/4=${tempo}
K:${key}
% Placeholder melody - to be generated by melody engine
C2 D2 E2 F2 | G2 A2 B2 c2 |]
w: Place-hold-er me-lo-dy here~`;

            console.log('[MelodyStore] Melody generated');

            set(
              {
                melody,
                abcNotation: abc,
                isGenerating: false,
                tempo,
                timeSignature,
                key,
              },
              false,
              'generateMelody/complete'
            );
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            console.error('[MelodyStore] Melody generation failed:', errorMessage);
            set(
              {
                isGenerating: false,
                error: errorMessage,
              },
              false,
              'generateMelody/error'
            );
          }
        },

        setMelody: (melody: Melody, abcNotation: string) => {
          console.log('[MelodyStore] Setting melody directly');
          set(
            {
              melody,
              abcNotation,
              isGenerating: false,
              error: null,
              tempo: melody.params.tempo,
              timeSignature: melody.params.timeSignature,
              key: melody.params.key,
            },
            false,
            'setMelody'
          );
        },

        setAbcNotation: (abc: string) => {
          console.log('[MelodyStore] Setting ABC notation');
          set(
            {
              abcNotation: abc,
            },
            false,
            'setAbcNotation'
          );
        },

        play: () => {
          console.log('[MelodyStore] Play');
          set(
            {
              playbackState: 'playing',
            },
            false,
            'play'
          );
        },

        pause: () => {
          console.log('[MelodyStore] Pause');
          set(
            {
              playbackState: 'paused',
            },
            false,
            'pause'
          );
        },

        stop: () => {
          console.log('[MelodyStore] Stop');
          set(
            {
              playbackState: 'stopped',
              currentTime: 0,
            },
            false,
            'stop'
          );
        },

        seek: (time: number) => {
          const state = get();
          const clampedTime = Math.max(0, Math.min(time, state.duration));
          console.log('[MelodyStore] Seek to:', clampedTime);
          set(
            {
              currentTime: clampedTime,
            },
            false,
            'seek'
          );
        },

        setCurrentTime: (time: number) => {
          set(
            {
              currentTime: time,
            },
            false,
            'setCurrentTime'
          );
        },

        setDuration: (duration: number) => {
          console.log('[MelodyStore] Set duration:', duration);
          set(
            {
              duration,
            },
            false,
            'setDuration'
          );
        },

        setTempo: (bpm: number) => {
          // Clamp tempo to reasonable range
          const clampedTempo = Math.max(40, Math.min(240, bpm));
          console.log('[MelodyStore] Set tempo:', clampedTempo);
          set(
            {
              tempo: clampedTempo,
            },
            false,
            'setTempo'
          );
        },

        setVolume: (volume: number) => {
          // Clamp volume to 0-1
          const clampedVolume = Math.max(0, Math.min(1, volume));
          console.log('[MelodyStore] Set volume:', clampedVolume);
          set(
            {
              volume: clampedVolume,
            },
            false,
            'setVolume'
          );
        },

        toggleLoop: () => {
          const newLoop = !get().loop;
          console.log('[MelodyStore] Toggle loop:', newLoop);
          set(
            {
              loop: newLoop,
            },
            false,
            'toggleLoop'
          );
        },

        setKey: (key) => {
          console.log('[MelodyStore] Set key:', key);
          set(
            {
              key,
            },
            false,
            'setKey'
          );
        },

        setTimeSignature: (ts) => {
          console.log('[MelodyStore] Set time signature:', ts);
          set(
            {
              timeSignature: ts,
            },
            false,
            'setTimeSignature'
          );
        },

        setError: (error: string | null) => {
          if (error) {
            console.error('[MelodyStore] Error:', error);
          }
          set(
            {
              error,
            },
            false,
            'setError'
          );
        },

        clear: () => {
          console.log('[MelodyStore] Clearing melody');
          set(
            {
              melody: null,
              abcNotation: null,
              playbackState: 'stopped',
              currentTime: 0,
              duration: 0,
              isGenerating: false,
              error: null,
            },
            false,
            'clear'
          );
        },

        reset: () => {
          console.log('[MelodyStore] Resetting store');
          set(initialState, false, 'reset');
        },
      }),
      {
        name: 'ghost-note-melody-store',
        partialize: (state) => ({
          tempo: state.tempo,
          volume: state.volume,
          loop: state.loop,
          key: state.key,
          timeSignature: state.timeSignature,
        }),
      }
    ),
    { name: 'MelodyStore' }
  )
);

// =============================================================================
// Selectors
// =============================================================================

/**
 * Check if melody is available
 */
export const selectHasMelody = (state: MelodyStore): boolean => {
  return state.abcNotation !== null;
};

/**
 * Check if currently playing
 */
export const selectIsPlaying = (state: MelodyStore): boolean => {
  return state.playbackState === 'playing';
};

/**
 * Check if currently paused
 */
export const selectIsPaused = (state: MelodyStore): boolean => {
  return state.playbackState === 'paused';
};

/**
 * Check if stopped
 */
export const selectIsStopped = (state: MelodyStore): boolean => {
  return state.playbackState === 'stopped';
};

/**
 * Check if generating
 */
export const selectIsGenerating = (state: MelodyStore): boolean => {
  return state.isGenerating;
};

/**
 * Get playback progress as percentage (0-100)
 */
export const selectPlaybackProgress = (state: MelodyStore): number => {
  if (state.duration === 0) return 0;
  return (state.currentTime / state.duration) * 100;
};

/**
 * Format current time as MM:SS
 */
export const selectFormattedCurrentTime = (state: MelodyStore): string => {
  const minutes = Math.floor(state.currentTime / 60);
  const seconds = Math.floor(state.currentTime % 60);
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
};

/**
 * Format duration as MM:SS
 */
export const selectFormattedDuration = (state: MelodyStore): string => {
  const minutes = Math.floor(state.duration / 60);
  const seconds = Math.floor(state.duration % 60);
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
};

/**
 * Get volume as percentage (0-100)
 */
export const selectVolumePercent = (state: MelodyStore): number => {
  return Math.round(state.volume * 100);
};

/**
 * Check if there's an error
 */
export const selectHasError = (state: MelodyStore): boolean => {
  return state.error !== null;
};
