/**
 * Ghost Note - Melody Store
 *
 * Manages melody generation, ABC notation, and playback state.
 *
 * PERFORMANCE NOTE: The abcRenderer module imports abcjs (~500KB).
 * To keep the initial bundle small, we use dynamic imports to load
 * the synth functions only when playback is actually requested.
 *
 * @module stores/useMelodyStore
 */

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import type { MelodyStore, MelodyState } from './types';
import type { PoemAnalysis } from '../types';
import type { Melody } from '../lib/melody/types';

// Type for the dynamically imported abcRenderer module
type AbcRendererModule = typeof import('../lib/music/abcRenderer');
type SynthState = 'uninitialized' | 'loading' | 'ready' | 'playing' | 'paused' | 'stopped' | 'error';

// Cached module reference
let abcRendererModule: AbcRendererModule | null = null;
let abcRendererLoadPromise: Promise<AbcRendererModule> | null = null;

/**
 * Lazily loads the abcRenderer module.
 * This keeps abcjs (~500KB) out of the initial bundle.
 */
async function loadAbcRenderer(): Promise<AbcRendererModule> {
  if (abcRendererModule) {
    return abcRendererModule;
  }

  if (abcRendererLoadPromise) {
    return abcRendererLoadPromise;
  }

  console.debug('[MelodyStore] Loading abcRenderer module...');
  const startTime = performance.now();

  abcRendererLoadPromise = import('../lib/music/abcRenderer')
    .then((module) => {
      abcRendererModule = module;
      const loadTime = Math.round(performance.now() - startTime);
      console.debug(`[MelodyStore] abcRenderer loaded in ${loadTime}ms`);
      return module;
    })
    .catch((error) => {
      console.error('[MelodyStore] Failed to load abcRenderer:', error);
      abcRendererLoadPromise = null;
      throw error;
    });

  return abcRendererLoadPromise;
}


// =============================================================================
// Constants
// =============================================================================

/**
 * Default element ID for the notation display container.
 * This is used to sync visual highlighting with audio playback.
 */
const NOTATION_ELEMENT_ID = 'notation-display-1';

// =============================================================================
// Initial State
// =============================================================================

const initialState: MelodyState = {
  melody: null,
  abcNotation: null,
  playbackState: 'stopped',
  currentTime: 0,
  duration: 0,
  tempo: 100,
  volume: 0.8,
  loop: false,
  key: 'C',
  timeSignature: '4/4',
  isGenerating: false,
  error: null,
};

// =============================================================================
// Store Implementation
// =============================================================================

export const useMelodyStore = create<MelodyStore>()(
  devtools(
    persist(
      (set, get) => ({
        // State
        ...initialState,

        // Actions
        generateMelody: async (lyrics: string, analysis: PoemAnalysis) => {
          if (!lyrics.trim()) {
            console.warn('[MelodyStore] Cannot generate melody for empty lyrics');
            get().setError('Cannot generate melody for empty lyrics');
            return;
          }

          console.log('[MelodyStore] Starting melody generation');

          set(
            {
              isGenerating: true,
              error: null,
            },
            false,
            'generateMelody/start'
          );

          try {
            // Get suggested parameters from analysis
            const suggestions = analysis.melodySuggestions;
            const state = get();

            // Use current settings or suggestions
            const key = state.key;
            const timeSignature = suggestions.timeSignature || state.timeSignature;
            const tempo = suggestions.tempo || state.tempo;

            // Simulate melody generation
            // In production, this would call the actual melody generator
            await new Promise((resolve) => setTimeout(resolve, 500));

            // Create placeholder melody
            const melody: Melody = {
              params: {
                title: analysis.meta.title || 'Untitled',
                timeSignature,
                defaultNoteLength: '1/8',
                tempo,
                key,
              },
              measures: [],
              lyrics: [],
            };

            // Generate simple ABC notation header
            const abc = `X:1
T:${melody.params.title}
M:${timeSignature}
L:1/8
Q:1/4=${tempo}
K:${key}
% Placeholder melody - to be generated by melody engine
C2 D2 E2 F2 | G2 A2 B2 c2 |]
w: Place-hold-er me-lo-dy here~`;

            console.log('[MelodyStore] Melody generated');

            set(
              {
                melody,
                abcNotation: abc,
                isGenerating: false,
                tempo,
                timeSignature,
                key,
              },
              false,
              'generateMelody/complete'
            );
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            console.error('[MelodyStore] Melody generation failed:', errorMessage);
            set(
              {
                isGenerating: false,
                error: errorMessage,
              },
              false,
              'generateMelody/error'
            );
          }
        },

        setMelody: (melody: Melody, abcNotation: string) => {
          console.log('[MelodyStore] Setting melody directly');
          set(
            {
              melody,
              abcNotation,
              isGenerating: false,
              error: null,
              tempo: melody.params.tempo,
              timeSignature: melody.params.timeSignature,
              key: melody.params.key,
            },
            false,
            'setMelody'
          );
        },

        setAbcNotation: (abc: string) => {
          console.log('[MelodyStore] Setting ABC notation');
          set(
            {
              abcNotation: abc,
            },
            false,
            'setAbcNotation'
          );
        },

        play: async () => {
          const state = get();
          const { abcNotation, playbackState } = state;

          console.log('[MelodyStore] Play requested, current state:', playbackState);

          // Can't play without ABC notation
          if (!abcNotation) {
            console.warn('[MelodyStore] Cannot play: no ABC notation available');
            get().setError('No melody to play');
            return;
          }

          // If already playing, ignore
          if (playbackState === 'playing') {
            console.log('[MelodyStore] Already playing, ignoring');
            return;
          }

          // Set loading state while synth initializes
          set(
            {
              playbackState: 'loading',
              error: null,
            },
            false,
            'play/loading'
          );

          try {
            // Lazily load the abcRenderer module
            const abcRenderer = await loadAbcRenderer();
            const synth = abcRenderer.getSynth();

            // If paused, resume playback
            if (playbackState === 'paused' && synth && synth.getState() === 'paused') {
              console.log('[MelodyStore] Resuming from paused state');
              const resumed = abcRenderer.resumePlayback();
              if (resumed) {
                set(
                  {
                    playbackState: 'playing',
                  },
                  false,
                  'play/resumed'
                );
              } else {
                console.warn('[MelodyStore] Failed to resume playback');
                set(
                  {
                    playbackState: 'paused',
                    error: 'Failed to resume playback',
                  },
                  false,
                  'play/resume-failed'
                );
              }
              return;
            }

            // Initialize synth with progress callbacks
            console.log('[MelodyStore] Initializing synth for fresh playback');
            await abcRenderer.initSynth({
              onProgress: (currentBeat, totalBeats, totalTime) => {
                // Convert beat progress to time
                // totalTime is in milliseconds from abcjs
                const progress = totalBeats > 0 ? currentBeat / totalBeats : 0;
                const currentTimeInSeconds = progress * (totalTime / 1000);
                const durationInSeconds = totalTime / 1000;

                // Update store state
                const store = useMelodyStore.getState();
                if (store.playbackState === 'playing') {
                  store.setCurrentTime(currentTimeInSeconds);
                  if (store.duration !== durationInSeconds && durationInSeconds > 0) {
                    store.setDuration(durationInSeconds);
                  }
                }
              },
              onStateChange: (synthState: SynthState) => {
                console.log('[MelodyStore] Synth state changed:', synthState);
                // Handle synth state changes
                if (synthState === 'stopped') {
                  const store = useMelodyStore.getState();
                  // Only reset if we didn't explicitly stop (i.e., playback finished naturally)
                  if (store.playbackState === 'playing') {
                    console.log('[MelodyStore] Playback finished naturally');
                    // Check if loop is enabled
                    if (store.loop && store.abcNotation) {
                      console.log('[MelodyStore] Loop enabled, restarting playback');
                      // Restart playback
                      setTimeout(() => {
                        store.play();
                      }, 100);
                    } else {
                      set(
                        {
                          playbackState: 'stopped',
                          currentTime: 0,
                        },
                        false,
                        'play/finished'
                      );
                    }
                  }
                }
              },
            });

            // Start playback using playMelody helper
            // This handles rendering, loading, and playing in one call
            console.log('[MelodyStore] Starting playMelody with notation');
            const success = await abcRenderer.playMelody(abcNotation, NOTATION_ELEMENT_ID);

            if (success) {
              console.log('[MelodyStore] Playback started successfully');
              set(
                {
                  playbackState: 'playing',
                },
                false,
                'play/started'
              );
            } else {
              console.error('[MelodyStore] playMelody returned false');
              set(
                {
                  playbackState: 'stopped',
                  error: 'Failed to start playback',
                },
                false,
                'play/failed'
              );
            }
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown playback error';
            console.error('[MelodyStore] Play error:', errorMessage);
            set(
              {
                playbackState: 'stopped',
                error: errorMessage,
              },
              false,
              'play/error'
            );
          }
        },

        pause: async () => {
          const state = get();
          console.log('[MelodyStore] Pause requested, current state:', state.playbackState);

          // Can only pause if playing
          if (state.playbackState !== 'playing') {
            console.log('[MelodyStore] Not playing, ignoring pause');
            return;
          }

          // Try to pause using the loaded module
          const abcRenderer = abcRendererModule;
          if (abcRenderer) {
            const paused = abcRenderer.pausePlayback();
            if (paused) {
              console.log('[MelodyStore] Paused successfully');
              set(
                {
                  playbackState: 'paused',
                },
                false,
                'pause'
              );
              return;
            }
          }

          console.warn('[MelodyStore] Failed to pause, synth may not be active');
          // Still update the state since the user expects it to be paused
          set(
            {
              playbackState: 'paused',
            },
            false,
            'pause/fallback'
          );
        },

        stop: () => {
          const state = get();
          console.log('[MelodyStore] Stop requested, current state:', state.playbackState);

          // Call the actual synth stop if we have the module loaded
          const abcRenderer = abcRendererModule;
          if (abcRenderer) {
            const synth = abcRenderer.getSynth();
            if (synth) {
              const stopped = abcRenderer.stopPlayback();
              if (stopped) {
                console.log('[MelodyStore] Stopped synth successfully');
              } else {
                console.log('[MelodyStore] Synth stop returned false (may already be stopped)');
              }
            }
          }

          // Always update the state
          set(
            {
              playbackState: 'stopped',
              currentTime: 0,
            },
            false,
            'stop'
          );
          console.log('[MelodyStore] Playback stopped and time reset');
        },

        seek: (time: number) => {
          const state = get();
          const clampedTime = Math.max(0, Math.min(time, state.duration));
          console.log('[MelodyStore] Seek to:', clampedTime);
          set(
            {
              currentTime: clampedTime,
            },
            false,
            'seek'
          );
        },

        setCurrentTime: (time: number) => {
          set(
            {
              currentTime: time,
            },
            false,
            'setCurrentTime'
          );
        },

        setDuration: (duration: number) => {
          console.log('[MelodyStore] Set duration:', duration);
          set(
            {
              duration,
            },
            false,
            'setDuration'
          );
        },

        setTempo: (bpm: number) => {
          // Clamp tempo to reasonable range
          const clampedTempo = Math.max(40, Math.min(240, bpm));
          console.log('[MelodyStore] Set tempo:', clampedTempo);
          set(
            {
              tempo: clampedTempo,
            },
            false,
            'setTempo'
          );
        },

        setVolume: (volume: number) => {
          // Clamp volume to 0-1
          const clampedVolume = Math.max(0, Math.min(1, volume));
          console.log('[MelodyStore] Set volume:', clampedVolume);
          set(
            {
              volume: clampedVolume,
            },
            false,
            'setVolume'
          );
        },

        toggleLoop: () => {
          const newLoop = !get().loop;
          console.log('[MelodyStore] Toggle loop:', newLoop);
          set(
            {
              loop: newLoop,
            },
            false,
            'toggleLoop'
          );
        },

        setKey: (key) => {
          console.log('[MelodyStore] Set key:', key);
          set(
            {
              key,
            },
            false,
            'setKey'
          );
        },

        setTimeSignature: (ts) => {
          console.log('[MelodyStore] Set time signature:', ts);
          set(
            {
              timeSignature: ts,
            },
            false,
            'setTimeSignature'
          );
        },

        setError: (error: string | null) => {
          if (error) {
            console.error('[MelodyStore] Error:', error);
          }
          set(
            {
              error,
            },
            false,
            'setError'
          );
        },

        clear: () => {
          console.log('[MelodyStore] Clearing melody');

          // Stop any active playback
          const abcRenderer = abcRendererModule;
          if (abcRenderer) {
            const synth = abcRenderer.getSynth();
            if (synth) {
              abcRenderer.stopPlayback();
            }
          }

          set(
            {
              melody: null,
              abcNotation: null,
              playbackState: 'stopped',
              currentTime: 0,
              duration: 0,
              isGenerating: false,
              error: null,
            },
            false,
            'clear'
          );
        },

        reset: () => {
          console.log('[MelodyStore] Resetting store');

          // Stop any active playback
          const abcRenderer = abcRendererModule;
          if (abcRenderer) {
            const synth = abcRenderer.getSynth();
            if (synth) {
              abcRenderer.stopPlayback();
            }
          }

          set(initialState, false, 'reset');
        },
      }),
      {
        name: 'ghost-note-melody-store',
        partialize: (state) => ({
          tempo: state.tempo,
          volume: state.volume,
          loop: state.loop,
          key: state.key,
          timeSignature: state.timeSignature,
        }),
      }
    ),
    { name: 'MelodyStore' }
  )
);

// =============================================================================
// Selectors
// =============================================================================

/**
 * Check if melody is available
 */
export const selectHasMelody = (state: MelodyStore): boolean => {
  return state.abcNotation !== null;
};

/**
 * Check if currently playing
 */
export const selectIsPlaying = (state: MelodyStore): boolean => {
  return state.playbackState === 'playing';
};

/**
 * Check if currently paused
 */
export const selectIsPaused = (state: MelodyStore): boolean => {
  return state.playbackState === 'paused';
};

/**
 * Check if stopped
 */
export const selectIsStopped = (state: MelodyStore): boolean => {
  return state.playbackState === 'stopped';
};

/**
 * Check if generating
 */
export const selectIsGenerating = (state: MelodyStore): boolean => {
  return state.isGenerating;
};

/**
 * Get playback progress as percentage (0-100)
 */
export const selectPlaybackProgress = (state: MelodyStore): number => {
  if (state.duration === 0) return 0;
  return (state.currentTime / state.duration) * 100;
};

/**
 * Format current time as MM:SS
 */
export const selectFormattedCurrentTime = (state: MelodyStore): string => {
  const minutes = Math.floor(state.currentTime / 60);
  const seconds = Math.floor(state.currentTime % 60);
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
};

/**
 * Format duration as MM:SS
 */
export const selectFormattedDuration = (state: MelodyStore): string => {
  const minutes = Math.floor(state.duration / 60);
  const seconds = Math.floor(state.duration % 60);
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
};

/**
 * Get volume as percentage (0-100)
 */
export const selectVolumePercent = (state: MelodyStore): number => {
  return Math.round(state.volume * 100);
};

/**
 * Check if there's an error
 */
export const selectHasError = (state: MelodyStore): boolean => {
  return state.error !== null;
};
